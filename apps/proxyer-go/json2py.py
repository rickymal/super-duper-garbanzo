#!/usr/bin/env python3
"""
json2py.py  –  converte todos os JSON de uma pasta em “DTOs” Python.

Exemplo de uso:
    python json2py.py --from ./json --to ./dto_py
O arquivo  user_profile.json  gera algo assim:

    # dto/user_profile.py
    # Code generated by json2py; DO NOT EDIT.
    # Source: user_profile.json

    from typespec import string, integer, float, boolean, array, object, any

    class UserProfile:
        id          = integer()
        name        = string(max_len=30)
        email       = string()
        is_active   = boolean()
"""

import argparse
import json
import keyword
import os
import re
import textwrap
from pathlib import Path
from typing import Any, Dict

# ───────────────────────── helpers ──────────────────────────


def snake_to_camel(name: str) -> str:
    """snake_case → CamelCase"""
    return "".join(part.capitalize() for part in name.split("_"))


def camel_to_snake(name: str) -> str:
    """CamelCase/Pascal → snake_case (para nome do arquivo)"""
    snake = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", name)
    snake = re.sub(r"([A-Z])([A-Z][a-z])", r"\1_\2", snake)
    return snake.lower()


def legalize_identifier(name: str) -> str:
    """
    Torna o identificador seguro para Python:
    - evita palavras reservadas (ex.: `class`, `from`)
    - troca caracteres inválidos por '_'
    """
    identifier = re.sub(r"\W|^(?=\d)", "_", name)
    if keyword.iskeyword(identifier):
        identifier += "_"
    return identifier


def choose_field_call(key: str, value: Any) -> str:
    """
    Decide qual “função-tipo” usar e quais metadados expor.
    Estrutura de retorno: string já na sintaxe Python, p.ex.  'string(max_len=20)'
    """
    if isinstance(value, str):
        # max_len = len(value)  (usamos amostra – pode expandir para arrays)
        return f"string(max_len={len(value)})" if value else "string()"

    if isinstance(value, bool):
        return "boolean()"

    if isinstance(value, int):
        return "integer()"

    if isinstance(value, float):
        return "float()"

    if isinstance(value, list):
        return "array()"  # Para algo mais avançado, inspecione itens

    if isinstance(value, dict):
        return "object()"

    # Fallback
    return "any()"


def build_class(class_name: str, data: Dict[str, Any]) -> str:
    """
    Gera o código Python da classe.
    Campos são alinhados usando o maior nome para uma saída legível.
    """
    # calcula padding para indentação alinhada
    longest_field = max(len(legalize_identifier(k)) for k in data.keys()) if data else 0
    pad = longest_field + 4  # 4 espaços mínimos

    lines = [f"class {class_name}:"]
    if not data:
        lines.append("    pass")
        return "\n".join(lines)

    for key, value in data.items():
        field_name = legalize_identifier(key)
        call = choose_field_call(key, value)
        # alinhamento bonito:
        spaces = " " * (pad - len(field_name))
        lines.append(f"    {field_name}{spaces}= {call}")
    return "\n".join(lines)


# ───────────────────────── main ──────────────────────────


def process_file(json_path: Path, out_dir: Path) -> None:
    with json_path.open("r", encoding="utf-8") as fp:
        data = json.load(fp)

    if not isinstance(data, dict):
        raise ValueError("JSON precisa representar um objeto (não array)")

    # Nome da classe = nome do arquivo (sem extensão) em CamelCase
    class_name = snake_to_camel(json_path.stem)
    class_code = build_class(class_name, data)

    out_filename = camel_to_snake(class_name) + ".py"
    out_path = out_dir / out_filename

    header = textwrap.dedent(
        f"""\

        # Code generated by json2py; DO NOT EDIT.
        # Source: {json_path.name}

        from typespec import string, integer, float, boolean, array, object, any

        """
    ).lstrip(
        "\n"
    )

    out_path.write_text(header + class_code + "\n", encoding="utf-8")
    print(f"✔︎  {json_path.name} → {out_path.relative_to(out_dir.parent)}")


def main() -> None:
    parser = argparse.ArgumentParser(description="Converte JSON em DTOs Python.")
    parser.add_argument("--from", dest="src", required=True, help="Pasta com JSONs")
    parser.add_argument("--to", dest="dst", required=True, help="Pasta de saída .py")
    args = parser.parse_args()

    src_dir = Path(args.src).resolve()
    dst_dir = Path(args.dst).resolve()
    dst_dir.mkdir(parents=True, exist_ok=True)

    json_files = list(src_dir.glob("*.json"))
    if not json_files:
        print("❗ Nenhum .json encontrado na pasta de origem.")
        return

    for jf in json_files:
        try:
            process_file(jf, dst_dir)
        except Exception as exc:
            print(f"⚠️  Falha ao processar {jf.name}: {exc}")


if __name__ == "__main__":
    main()
